## 병렬 커넥션
### 특징
- 순차적인 트랜잭션 처리의 단점을 극복
- HTTP 는 클라이언트가 여러 개의 커넥션을 맺음으로써 여러개의 HTTP 트랜잭션을 병렬로 처리할 수 있게 한다.
- 클라이언트의 인터넷 대역폭을 한 개의 커넥션이 다 써버리는 것이 아니라 나머지 객체를 내려받는 데에 남은 대역폭을 사용할 수 있다.

### 단점
- 대역폭이 좁을 경우에는 성능상의 장점이 없어진다.
- 다수의 커넥션은 메모리를 많이 소모하고 자체적인 성능 문제를 발생시킨다.

* 브라우저는 실제로 병렬 커넥션을 사용하긴하지만 적은 수의 병렬 커넥션만 허용한다.

## 지속 커넥션
### 사이트 지역성
웹 페이지에 있는 상당수의 자료들을 내려받기 위해 같은 서버에 또 다시 요청을 하게 되는데 이를 지역성이라고 한다.

### 특징
- 지속 커넥션은 클라이언트나 서버가 커넥션을 끊기 전까지는 트랜잭션 간에 커넥션을 유지한다. 
- 지속 커넥션을 재사용함으로서 커넥션을 맺기 위한 준비작업 시간을 절약할 수 있다.
- 커넥션을 위한 사전작업과 지연을 줄여주고, 튜닝된 커넥션을 유지하며, 커넥션의 수를 줄여준다.

### 단점
- 잘못 관리할 경우, 계속 연결된 상태로 수많은 커넥션들이 쌓일 수 있다.

### HTTP 1.0 / Keep-Alive
- 지속 커넥션을 지원하기 위해 확장되었다.
- 커넥션을 유지하기 위해 클라이언트는 요청에 Connection:Keep-Alive 헤더를 포함시킨다. 만약 서버의 응답헤더에도 Keep-Alive가 없다면 연결을 끊을 것이라고 추정한다.

### Keep-Alive 옵션
```
Connection: Keep-Alive
Keep-Alive: max=5; timeout=120;
```
- timeout : 커넥션이 얼마간 유지될 것인지
- max : 몇개의 HTTP 트랜잭션을 처리할때까지 유지할것인지

### HTTP 1.1의 지속커넥션
- HTTP 1.0과는 달리 기본으로 활성화 되어있으며, 커넥션을 끊을경우 Connection:close 헤더를 명시한다.
- 만약 Connection:close 헤더가 없으면 응답후에도 커넥션을 계속 유지하는 것으로 추정한다.
- 하나의 사용자 클라이언트는 서버의 과부하 방지를 위하여 넉넉잡아 2개의 지속 커넥션만을 유지해야 한다.


## 파이프라인 커넥션
- HTTP 1.1은 지속 커넥션을 통해서 요청을 파이프라이닝 할 수 있다. keep-alive 성능을 더 높여준다.
- 여러 개의 요청은 응답이 도착하기 전까지 큐에 쌓인다.
- 네트워크 상의 왕복으로 인한 시간을 줄여서 성능을 높여준다.

### 제약사항
- 지속 커넥션인지 확인하기전까지는 파이프라인을 이어서는 안된다.
- 응답은 요청 순서와 같게 와야한다. (순번이 매겨져 있지 않으므로)
- 완료되지 않은 요청이 파이프라인에 있으면 언제든 다시 요청을 보낼 준비가 되어있어야 한다.
- 비멱등 (POST와 같은) 요청을 보내서는 안된다.

### 커넥션 끊기
- HTTP 클라이언트, 서버, 프락시는 언제든지 TCP 전송 커넥션을 끊을 수 있는 상황이다.
- HTTP 응답은 정확한 크기값을 가지는 Content-Length 헤더를 가지고 있어야 하는데, 클라이언트나 프락시가 커넥션이 끊어졌다는 응답을 받은 후,
실제 전달된 엔티티의 길이와 Content-Length의 값이 일치하지 않다면 데이터의 정확한 길이를 서버에게 물어봐야한다.
- HTTP 어플리케이션은 예상치 못하게 커넥션이 끊어졌을 떄 적절히 대응할 수 있는 준비가 되어있어야 한다.

## 전체 끊기와 절반 끊기
- close() : 전체끊기. 입력채널과 출력 채널의 커넥션을 모두 끊는다.
- shutdown() : 절반 끊기. 입력채널이나 출력 채널 중 하나를 끊는다.

### 우아한 커넥션 끊기
- 예기치않게 커넥션을 끊어야 한다면 우아하게 커넥션을 끊어야한다.
- 애플리케이션 자신의 출력채널을 끊고 다른쪽에 있는 기기의 출력채널이 끊기는 것을 기다린다.
- 상대방이 절반 끊기를 구현했다는 보장이 없기 때문에 입력 채널에 대한 상태 검사도 주기적으로 해야한다.
